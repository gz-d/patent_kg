{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "/home/guanzhideng145/research/ip_portal/patent_kg/patents/130-US8,019,804(active).pdf"}, "page_content": "Step IV: SSD= \u201cssD+q,; PE \u5168 ys Ifnot the last f* coef- ficient, goto Step I.\n\nStep 5: Entropy code of the Z to find the number of bits encode the block: R=VLC(Z)\n\nFIG. 9 shows a possible hardware structure for carrying out the iterative table-lookup quantization process. Data 500 from an integer image transformed residual block F* is input to the hardware system 510. The data comprises all the coef- ficients f,,* of the block. As each coefficient does not depend on the others, the quantization process can be performed in parallel. In the other words, all the inverse quantized coeffi- cients f,,* are found simultaneously. Accordingly, each coef- ficient f,,* is input to a respective circuit 520, 530, 540 and the pre-scaled quantization and inverse quantization is carried out in parallel for each coefficient. FIG. 9 only shows in detail the circuits for calculating f,,*, f,,* and f,,*, but it is to be understood there will be a similar circuit for each coefficient.\n\nStep 6: Calculate the R-D cost: Jpn=SSD+A-R\n\nIn the above procedures, we assume that the boundaries of quantization sub-zones (having values +0. 5)A,, for k-0, 1, . .), the scaling factor or its square q,; ? and the quantization te A, for each position region of (i,j) are loaded in the encoder and stored in a look up table during the initial pro- cess. The above method has the advantage that arithmetic operations are avoided and only a simple comparison opera- tion between If,,*| and boundary points is required. Therefore, it is very suitable for hardware implementation.\n\nAn overview of the conventional SSD(S,C) calculation shown in FIG. 7 and contrasted with a preferred embodiment the invention in FIG. 8.", "type": "Document"}}