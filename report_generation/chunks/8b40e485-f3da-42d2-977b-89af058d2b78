{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "/home/guanzhideng145/research/ip_portal/patent_kg/patents/1235_US20240143524A1.pdf"}, "page_content": "[0066] In Algorithm 1, the \u00a2 is a 256-bit true random number (i.e. Step 1), and is expanded by the SHAKE256 to get the p, \u00a2, K (ie. Step 2). The \u00a2 is extended by the SHAKE 128, which generates short vectors si, sa after rejec- tion sampling (i.e. Step 3). The p is extended by the SHAKE128 to generate polynomial matrix A after rejection sampling (i.e. Step 4). Because Dilithium is designed based on the MLWE problem, A is a polynomial matrix, but not a vector. NTT is used in polynomial matrix-vector multipli- cation (i.e. Step 5-7). Note that A is sampled in the NTT domain, no further transformation is needed. The Power2Round breaks up high and low bits to shrink the key size (i.e. Step 9). The outputs pk and sk are packed and stored for Sign and Verify (i.e. Step 11).\n\nAlgorithm 1 Dilithium\u2019s Key Generation[2]\n\nOutput: Public key pk, Secrete key sk\n\n1 G<\u2014 {0, 1}26\n\n-continued\n\nAlgorithm 1 Dilithium\u2019s Key Generation[2] + (1, so) cs x Sr = Hyg AERP := Hi2s(p) \u52a0 -NEree) \u00b0 \u56fe -\u548c \u56fe #/ Polynomial Matrix-Vector Multiplication (Point- wise Multiplication + Point-wise Addition) m, =INIT@) t:= ma+s \u2014 # Point-wise Addition : (ty, te) := Power2Round,(t, d) : tr {0, 194 = Hyse(plity) : Pack pk = (p, ty), pack sk = (p, K, tr, 81, 595 to)\n\n\u00ae indicates text missing or illegible when filed", "type": "Document"}}