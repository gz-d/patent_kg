{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "/home/guanzhideng145/research/ip_portal/patent_kg/patents/1235_US20240143524A1.pdf"}, "page_content": "\u00ae indicates text missing or illegible when filed\n\n[0067] In Algorithm 2, the packed sk is unpacked for Sign (ie. Step 1). The SHAKE256 is used for hashing input messages and keys (i.e. Step 2-3). The masking vector y is expanded from p', K by using the SHAKE2S56, and its coefficients are within the range [-y,, y,) (i.e. Step 8). The polynomial matrix-vector multiplication A-y is calculated and the HighBits is used to get the high-order bits w, (i.e. Step 9-12). The challenge cis obtained by hashing the tr, M, w, with the SHAKE256, then sampled with t random positions to be +1 and the others be 0 (i.e. Step 13-14). The cis used to generate the potential signature z (i.e. Step 15-17). Note that less bits are used to store the signature, it needs to generate the hints h before compression to ensure the correctness in Verify (ie. Step 25). There are four conditions to check whether z will leak information (i.e. Step 21, 26). If yes, the signature will be rejected and then generated again.\n\n2: (p, \u00a2 K) E {0, 1\u00b0? := Hose (6)\n\nAlgorithm 2 Dilithium\u2019s Sign[2]\n\nInput: Secrete key sk, Message M", "type": "Document"}}